# -*- coding: utf-8 -*-
"""czi-tiling.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1iMf2BGFdzx2Ikid3lZYKIjWdx2xPTxn3

# CZI Tiling
"""
import time
import gc 
# Imports
import czifile
import matplotlib.pyplot as plt
import numpy as np
from pathlib import Path
from shutil import rmtree
import cv2 as cv
from tqdm.notebook import tqdm

import argparse


import os
#"/cache/Shivam/abeta_wmgm/Finished_batch/new_round_4March/wsis/"#"/cache/Shivam/R01 Batch 1/"
# argparse: get input and output directories
parser = argparse.ArgumentParser()
parser.add_argument("--path_wsi", type=str, required=True, help="Directory containing .czi files")
parser.add_argument("--save_dir", type=str, required=True, help="Output directory for tiles")
args = parser.parse_args()

from pathlib import Path  # already imported above; safe if duplicated
path_wsi = Path(args.path_wsi)
out_root = Path(args.save_dir)

wsi_names = os.listdir(path_wsi)


print(wsi_names)
couldnt_tile=[]
for wsi in wsi_names:
    if wsi[-3:]!="czi":
        continue
    
    print("Now processing, ",wsi)
    save_dir = out_root / wsi
    if save_dir.exists():
        continue

    # save_dir = "/cache/Shivam/abeta_wmgm/Finished_batch/new_round_4March/norm_tiles_batch10_parietal/"+wsi

    # if wsi=="02-145-Temporal_4G8.czi" or wsi=="10-419-Parietal_4G8.czi" or wsi=='10-813-Parietal_4G8.czi' or wsi=='11-135-Parietal_4G8.czi':
    #     print("skipping ",wsi,"as it always kills the process")
    #     couldnt_tile.append(wsi)
    #     continue
    
    # if os.path.exists(save_dir):
    #     print("Skipping since, WSI already tiled: ",save_dir)
    #     continue

    readstart = time.time()
    try:
        img = czifile.imread(str(path_wsi / wsi))  
    except:
        print("skipped due to large size :", str(path_wsi / wsi))
        couldnt_tile.append(wsi)
        continue
    print("Time taken to read the czi file",time.time()-readstart)

    # Print the metadata of the CZI file.
    # NOTE: returns as a string, looks like an XML file, the data is in there somewhere...
    # czifile.CziFile("NA5090-02_AT8.czi").metadata()

    print("Shape of image: ", img.shape)

    # Extract the data from the shape of image.
    h, w, c = img.shape[2:5]  # first two channels are just 1 for scene and time
    print(f"Heigth: {h}, Width: {w}, Channels: {c}")
    # Set variables for tiling.
    um_per_px = 0.5 #0.22 #0.5  # desired resolution in um / px
    tile_size = 1536 #1280
    

    # Calculate scale factors.
    scan_to_desired_res = 0.11 / um_per_px  

    tile_size_scan = int(tile_size / scan_to_desired_res)

    # Clean the save directory if it exists.
    save_dir = Path(save_dir)

    if save_dir.exists():
        rmtree(save_dir, ignore_errors=True)

    # Create the level directory (copying how pyvips tiles for consistency).
    level_dir = save_dir / "0"
    level_dir.mkdir(parents=True)

    def process_row(row_index, y):
        # Create directory for row.
        row_dir = level_dir / str(row_index)
        row_dir.mkdir()

        # Loop through each tile in row.
        for x_index, x in enumerate(range(0, w, tile_size_scan)):
            # Get the tile image.
            tile = img[0, 0, y:y+tile_size_scan, x:x+tile_size_scan]

            # If at the edge, pad the image with white (pyvips behavior).
            tile_h, tile_w = tile.shape[:2]
            if (tile_h, tile_w) != (tile_size_scan, tile_size_scan):
                # Pad with opencv.
                tile = cv.copyMakeBorder(
                    tile,
                    0,
                    tile_size_scan - tile_h,
                    0,
                    tile_size_scan - tile_w,
                    cv.BORDER_CONSTANT,
                    value=[255, 255, 255]
                )

            if tile.shape[:2] != (tile_size, tile_size):
                # Rescale the image to match the desired resolution.
                tile = cv.resize(tile, (tile_size, tile_size))


            # If we do Reinhard normalization, do it here!

            # Save the image.
            tile = cv.cvtColor(tile, cv.COLOR_RGB2BGR)  # opencv expects BGR image
            cv.imwrite(str(row_dir / f"{x_index}.jpg"), tile)
            del tile

        gc.collect()
    # Run in series.
    start=time.time()
    ys = list(range(0, h, tile_size_scan))

    for row_index, y in enumerate(tqdm(ys)):
        process_row(row_index, y)

    print("the process took seconds:",time.time()-start)
    print("Couldnt process these wsis due to large size",couldnt_tile)
    
    del img
    gc.collect()
    # exit()

